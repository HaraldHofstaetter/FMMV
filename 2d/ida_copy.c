/* This file is automatically generated by gen_gen_neighbor2_list.py */
/* DO NOT EDIT! */

#include"_fmmv.h"

#undef FMM_KIND
#define FMM_KIND FMM_STANDARD
#include"fmmv_access.h"

static void copy_particles_standard(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
}

static void copy_charges_standard(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}
}

static void backcopy_pot_standard(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}
}

static void zero_pot_standard(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_ST_STANDARD
#include"fmmv_access.h"

static void copy_particles_standard_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	_FLOAT_ (*targets)[2] = FMMV->targets;
	int *permTargets = FMMV->permTargets;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
	for (i = 0; i < FMMV->NTargets; i++) {
			access_tx(i) = targets[permTargets[i]][0];
			access_ty(i) = targets[permTargets[i]][1];
	}
}

static void copy_charges_standard_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}
}

static void backcopy_pot_standard_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}
}

static void zero_pot_standard_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_DIPOLE
#include"fmmv_access.h"

static void copy_particles_dipole(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
}

static void copy_charges_dipole(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	_FLOAT_ (*dipoleMoments)[2] =  FMMV->dipoleMoments;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}

	if (dipoleMoments==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = 0.0;
				access_my(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = dipoleMoments[perm[i]][0];
				access_my(i) = dipoleMoments[perm[i]][1];
		}
	}
}

static void backcopy_pot_dipole(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}
}

static void zero_pot_dipole(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_ST_DIPOLE
#include"fmmv_access.h"

static void copy_particles_dipole_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	_FLOAT_ (*targets)[2] = FMMV->targets;
	int *permTargets = FMMV->permTargets;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
	for (i = 0; i < FMMV->NTargets; i++) {
			access_tx(i) = targets[permTargets[i]][0];
			access_ty(i) = targets[permTargets[i]][1];
	}
}

static void copy_charges_dipole_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	_FLOAT_ (*dipoleMoments)[2] =  FMMV->dipoleMoments;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}

	if (dipoleMoments==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = 0.0;
				access_my(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = dipoleMoments[perm[i]][0];
				access_my(i) = dipoleMoments[perm[i]][1];
		}
	}
}

static void backcopy_pot_dipole_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}
}

static void zero_pot_dipole_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_GRAD
#include"fmmv_access.h"

static void copy_particles_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
}

static void copy_charges_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}
}

static void backcopy_pot_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	_FLOAT_ (*gradients)[2] =  FMMV->gradients;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}

	if (gradients!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
				gradients[permTargets[i]][0] = access_gradx(i);
				gradients[permTargets[i]][1] = access_grady(i);
		}
	}
}

static void zero_pot_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}

	for (i = 0; i < FMMV->NTargets; i++) {
			access_gradx(i) = 0.0;
			access_grady(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_ST_GRAD
#include"fmmv_access.h"

static void copy_particles_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	_FLOAT_ (*targets)[2] = FMMV->targets;
	int *permTargets = FMMV->permTargets;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
	for (i = 0; i < FMMV->NTargets; i++) {
			access_tx(i) = targets[permTargets[i]][0];
			access_ty(i) = targets[permTargets[i]][1];
	}
}

static void copy_charges_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}
}

static void backcopy_pot_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	_FLOAT_ (*gradients)[2] =  FMMV->gradients;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}

	if (gradients!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
				gradients[permTargets[i]][0] = access_gradx(i);
				gradients[permTargets[i]][1] = access_grady(i);
		}
	}
}

static void zero_pot_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}

	for (i = 0; i < FMMV->NTargets; i++) {
			access_gradx(i) = 0.0;
			access_grady(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_DIPOLE_GRAD
#include"fmmv_access.h"

static void copy_particles_dipole_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
}

static void copy_charges_dipole_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	_FLOAT_ (*dipoleMoments)[2] =  FMMV->dipoleMoments;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}

	if (dipoleMoments==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = 0.0;
				access_my(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = dipoleMoments[perm[i]][0];
				access_my(i) = dipoleMoments[perm[i]][1];
		}
	}
}

static void backcopy_pot_dipole_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	_FLOAT_ (*gradients)[2] =  FMMV->gradients;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}

	if (gradients!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
				gradients[permTargets[i]][0] = access_gradx(i);
				gradients[permTargets[i]][1] = access_grady(i);
		}
	}
}

static void zero_pot_dipole_grad(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}

	for (i = 0; i < FMMV->NTargets; i++) {
			access_gradx(i) = 0.0;
			access_grady(i) = 0.0;
	}
}

#undef FMM_KIND
#define FMM_KIND FMM_ST_DIPOLE_GRAD
#include"fmmv_access.h"

static void copy_particles_dipole_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	_FLOAT_ (*particles)[2] = FMMV->particles;
	int *perm = FMMV->perm;
	_FLOAT_ (*targets)[2] = FMMV->targets;
	int *permTargets = FMMV->permTargets;
	int i;
	for (i = 0; i < FMMV->NParticles; i++) {
			access_x(i) = particles[perm[i]][0];
			access_y(i) = particles[perm[i]][1];
	}
	for (i = 0; i < FMMV->NTargets; i++) {
			access_tx(i) = targets[permTargets[i]][0];
			access_ty(i) = targets[permTargets[i]][1];
	}
}

static void copy_charges_dipole_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *perm = FMMV->perm;
	_FLOAT_ *charges = FMMV->charges;
	_FLOAT_ (*dipoleMoments)[2] =  FMMV->dipoleMoments;
	int i;

	if (charges==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
			access_q(i) = charges[perm[i]];
		}
	}

	if (dipoleMoments==0) {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = 0.0;
				access_my(i) = 0.0;
		}
	}
	else {
		for (i = 0; i < FMMV->NParticles; i++) {
				access_mx(i) = dipoleMoments[perm[i]][0];
				access_my(i) = dipoleMoments[perm[i]][1];
		}
	}
}

static void backcopy_pot_dipole_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int *permTargets = FMMV->permTargets;
	_FLOAT_ *potentials = FMMV->potentials;
	_FLOAT_ (*gradients)[2] =  FMMV->gradients;
	int i;


	if (potentials!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
			potentials[permTargets[i]] = access_pot(i);
		}
	}

	if (gradients!=0) {
		for (i = 0; i < FMMV->NTargets; i++) {
				gradients[permTargets[i]][0] = access_gradx(i);
				gradients[permTargets[i]][1] = access_grady(i);
		}
	}
}

static void zero_pot_dipole_grad_st(FmmvHandle *FMMV)
{
	DEFINE_IDA_LOCAL_ALIASES(FMMV)
	int i;

	for (i = 0; i < FMMV->NTargets; i++) {
		access_pot(i) = 0.0;
	}

	for (i = 0; i < FMMV->NTargets; i++) {
			access_gradx(i) = 0.0;
			access_grady(i) = 0.0;
	}
}

void copy_particles(FmmvHandle *FMMV)
{
	switch(FMMV->dataKind) {
	case FMM_STANDARD:
		copy_particles_standard(FMMV);
		break;
	case FMM_DIPOLE:
		copy_particles_dipole(FMMV);
		break;
	case FMM_GRAD:
		copy_particles_grad(FMMV);
		break;
	case FMM_DIPOLE_GRAD:
		copy_particles_dipole_grad(FMMV);
		break;
	case FMM_ST_STANDARD:
		copy_particles_standard_st(FMMV);
		break;
	case FMM_ST_DIPOLE:
		copy_particles_dipole_st(FMMV);
		break;
	case FMM_ST_GRAD:
		copy_particles_grad_st(FMMV);
		break;
	case FMM_ST_DIPOLE_GRAD:
		copy_particles_dipole_grad_st(FMMV);
		break;
	}
}

void copy_charges(FmmvHandle *FMMV)
{
	switch(FMMV->dataKind) {
	case FMM_STANDARD:
		copy_charges_standard(FMMV);
		break;
	case FMM_DIPOLE:
		copy_charges_dipole(FMMV);
		break;
	case FMM_GRAD:
		copy_charges_grad(FMMV);
		break;
	case FMM_DIPOLE_GRAD:
		copy_charges_dipole_grad(FMMV);
		break;
	case FMM_ST_STANDARD:
		copy_charges_standard_st(FMMV);
		break;
	case FMM_ST_DIPOLE:
		copy_charges_dipole_st(FMMV);
		break;
	case FMM_ST_GRAD:
		copy_charges_grad_st(FMMV);
		break;
	case FMM_ST_DIPOLE_GRAD:
		copy_charges_dipole_grad_st(FMMV);
		break;
	}
}

void backcopy_pot(FmmvHandle *FMMV)
{
	switch(FMMV->dataKind) {
	case FMM_STANDARD:
		backcopy_pot_standard(FMMV);
		break;
	case FMM_DIPOLE:
		backcopy_pot_dipole(FMMV);
		break;
	case FMM_GRAD:
		backcopy_pot_grad(FMMV);
		break;
	case FMM_DIPOLE_GRAD:
		backcopy_pot_dipole_grad(FMMV);
		break;
	case FMM_ST_STANDARD:
		backcopy_pot_standard_st(FMMV);
		break;
	case FMM_ST_DIPOLE:
		backcopy_pot_dipole_st(FMMV);
		break;
	case FMM_ST_GRAD:
		backcopy_pot_grad_st(FMMV);
		break;
	case FMM_ST_DIPOLE_GRAD:
		backcopy_pot_dipole_grad_st(FMMV);
		break;
	}
}

void zero_pot(FmmvHandle *FMMV)
{
	switch(FMMV->dataKind) {
	case FMM_STANDARD:
		zero_pot_standard(FMMV);
		break;
	case FMM_DIPOLE:
		zero_pot_dipole(FMMV);
		break;
	case FMM_GRAD:
		zero_pot_grad(FMMV);
		break;
	case FMM_DIPOLE_GRAD:
		zero_pot_dipole_grad(FMMV);
		break;
	case FMM_ST_STANDARD:
		zero_pot_standard_st(FMMV);
		break;
	case FMM_ST_DIPOLE:
		zero_pot_dipole_st(FMMV);
		break;
	case FMM_ST_GRAD:
		zero_pot_grad_st(FMMV);
		break;
	case FMM_ST_DIPOLE_GRAD:
		zero_pot_dipole_grad_st(FMMV);
		break;
	}
}

