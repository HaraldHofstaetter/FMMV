# FMMV - the Fastest Multipole Method of Vienna
# Copyright (c) 2006-2015 Harald Hofstaetter
# http://www.harald-hofstaetter.at
#
# This file is part of FMMV.
#
# FMMV is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# FMMV is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with FMMV; if not, write to the Free Software  Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

from gen_straightline_code import Op, var, parameter, templates, begin_block, end_block 
from math import tan, sin, cos, pi


def gen_FFT_M2X_prepare(funname, M):
	type = Op.templates["type"] 	
	basetype = Op.templates["basetype"]
	
	begin_block('void %s(%s *x, %s *y, %s *h)\n' % (funname, basetype, basetype, type))
	x = parameter("x", array=True)
	y = parameter("y", array=True)
	
	f0 = var("f0")
	f1 = var("f1")
	f2 = var("f2")
	f3 = var("f3")
	s = var("s")
	print

	#for j in range(M/4):		
	#	y[2*j]     ^= x[4*j]   + x[4*j+2]
	#	y[2*j+1]   ^= x[4*j+1] + x[4*j+3]
	#	y[M-2*j-2] ^= x[4*j+4] - x[4*j+2]
	#	y[M-2*j-1] ^= x[4*j+3] - x[4*j+5]

	f0 ^= x[0]
	f1 ^= x[1]
	f2 ^= x[2]
	f3 ^= x[3]
	s ^= 0
	
	for j in range(M/4):		
		y[2*j]     ^= f0 + f2
		y[2*j+1]   ^= f1 + f3
		f0 ^= x[4*j+4]
		f1 ^= x[4*j+5]
		y[M-2*j-2] ^= f0 - f2
		y[M-2*j-1] ^= f3 - f1
		if j<M/4-1:
			if (j%2):
				s ^= s + f0
			else:			
				s ^= s - f0
			f2 ^= x[4*j+6]
			f3 ^= x[4*j+7]
	s ^= 2*s + f0 +x[0]		

	print '\t*h = s;'				
	end_block()
	print


def gen_FFT_M2X_finish(funname, M):
	type = Op.templates["type"] 	
	basetype = Op.templates["basetype"]
	
	begin_block('void %s(%s *y, %s s)\n' % (funname, basetype, type))
	y = parameter("y", array=True)
	s = parameter("s")
	f = var("f")
	print

	for j in range(1,M/4):
		f ^= y[2*j+1]
		if j==M/8:
			y[2*j]   ^= y[2*j] - f
		else:
			y[2*j]   ^= y[2*j] - tan(2.0*pi*j/M)*f
		y[2*j+1] ^= (1.0/cos(2.0*pi*j/M))*f
	print	
	for j in range(M/4+1,M/2):
		f ^= y[2*j+1]
		if j==3*M/8:
			y[2*j]   ^= y[2*j] + f
		else:
			y[2*j]   ^= y[2*j] + (-tan(2.0*pi*j/M))*f
		y[2*j+1] ^= (1.0/cos(2.0*pi*j/M))*f
	print	
	f ^= y[M/2]-s
	y[M/2] ^= s
	y[M/2+1] ^= f

	end_block()
	print
	


def gen_FFT_X2L_prepare(funname, M):
	type = Op.templates["type"] 	
	basetype = Op.templates["basetype"]
	
	begin_block('void %s(%s *y, %s *h)\n' % (funname, basetype, type))
	y = parameter("y", array=True)
	f = var("f")
	g = var("g")
	s = var("s")
	print
	# A factor 2 is missing, to be compensated in D_w_over_M
	
	s ^= y[0]
	y[0] ^= s
	y[1] ^= y[1]
	for j in range(1,M/2):
		f ^= y[2*j+1]
		g ^= y[2*j]
		s ^= s+g
		if j==M/4:
			y[2*j]   ^= g + f
			y[2*j+1] ^= 0
		else:
			y[2*j]   ^= g + (sin(2.0*pi*j/M))*f
			y[2*j+1] ^=  (cos(2.0*pi*j/M))*f

	print '\t*h = s;'				
	end_block()
	print

	
def gen_FFT_X2L_finish(funname, M):
	type = Op.templates["type"] 	
	basetype = Op.templates["basetype"]
	
	begin_block('void %s(%s *x, %s *y, %s s)\n' % (funname, basetype, basetype, type))
	x = parameter("x", array=True)
	y = parameter("y", array=True)
	s = parameter("s")
	f0 = var("f0")
	f1 = var("f1")
	f2 = var("f2")
	f3 = var("f3")
	print

	#y[0] ^= s;
	#y[1] ^= 0.0;
	#y[2] ^= x[0] - y[0];
	#y[3] ^= x[1];	
	#for j in range(1, M/4):
	#	y[4*j]   ^=  x[M-2*j]   + y[4*j-2];
	#	y[4*j+1] ^=  y[4*j-1]   - x[M-2*j+1];	
	#	y[4*j+2] ^=  x[2*j]     - y[4*j];	
	#	y[4*j+3] ^=  x[2*j+1]   - y[4*j+1];
	#y[M]   ^= x[M/2] + y[M-2];
	#y[M+1] ^= 0.0;	

	f0 ^= s;
	f1 ^= 0.0;
	f2 ^= x[0] - f0;
	f3 ^= x[1];	
	y[0] ^= f0
	y[1] ^= f1
	y[2] ^= f2
	y[3] ^= f3
	for j in range(1, M/4):
		f0 ^=  x[M-2*j] + f2
		f1 ^=  f3 - x[M-2*j+1]
		y[4*j] ^= f0
		y[4*j+1] ^= f1
		f2 ^=  x[2*j]   - f0	
		f3 ^=  x[2*j+1] - f1
		y[4*j+2] ^= f2
		y[4*j+3] ^= f3
		
	y[M]   ^= x[M/2] + f2;
	y[M+1] ^= 0.0;	
	end_block()
	print
	
	

Op.templates = templates["generic"]
M_list = [4, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128]

print '''
/* This file is automatically generated by gen_FFT_M2X_X2L_aux.py */
/* DO NOT EDIT! */

#include"_fmmv.h"
'''
import sys

if len(sys.argv)>1:
	par = sys.argv[1]
	print '#include "simd.h"'
	print "#if (FMM_PRECISION==0)"
        print '   #include"%ss.h"' % par
        print "#else"
        print '   #include"%sd.h"' % par
        print "#endif"
	suf = "_"+par
        Op.templates = templates[par]
else:
	suf = ""
    	Op.templates = templates["generic"]
#Op.templates["USE_FMA"] = True

for M in M_list:
	gen_FFT_M2X_prepare("FFT_M2X_%i_prepare%s" %(M/2, suf), M)	
	gen_FFT_M2X_finish("FFT_M2X_%i_finish%s" %(M/2, suf), M)	
	gen_FFT_X2L_prepare("FFT_X2L_%i_prepare%s" %(M/2, suf), M)	
	gen_FFT_X2L_finish("FFT_X2L_%i_finish%s" %(M/2, suf), M)	
	

	

