\chapter{Data Structures}
%- Input: Points (optionally separate sources and targets),
%     charges, dipole moments
%- Output: potential, gradient (force)
%- Box3D
%- Build Tree:
%    octtree
%    radix sort 
%    space filling curves
%    Hilbert, Molton	
%- "IDA": SIMD (2-way and 4-way) copy sorted input into internal data
%   arrangement better suited for vectorization	
%- generate neighbor relations 
%\end{verbatim}

% choice of programming language:
%   complex algorihm - complex data structures
%   C more convenient than Fortran
%   much code automatically generated by high level language (Python)
%   content of this chapter not dependent on specific coulomb potential
%   but valid for other versions of FMM (2D versions can be derived in an obvious way).
%
% input: particles (C declartion, copied for sorting (at the same time scaling),
%                   contents of input arrays unchanged on output, )
%        charges, dipole moments
%        targets (optional)
% output: potential, optionally gradient
%
% sorting (general remarks)
% - during building of oct-tree data structure copy of array particles 
%   (and optionally of array targets) are sorted
% - for reasons of performance actually permuted in storage
% - but permutation vector is also generated 
%    potential and dipole moments have also be permuted, 
%    also pot (grad) from sorted to original order (inverse permutation)
%    sorted arrays particles (targets) is actually deallocated after
%    sorting, but recreated by building up the internal data arrangement (see next item) 
% - internal data arrangement (cf. intel compiler documentation, AoS, SoA)
%   access to input and output data not directly but through macros
%   more flexibility, ida influences performance significantly
%   ida needs not be specified definitely, best one can be determined by experiments 
%   vectorization: combine 4 (or 2) values "of the same kind" ,e.g. x-coordinates
%   of 4 particles.
%
% Build Oct-Tree Data Structure
%    declararation of Box3D, 
%        tree topology by 8 pointers to childs per box
%        boxes also horizontally linked, for easy going through
%        all boxes of some given level
%    enum constants Childs3D and Neighbors3D
%    pseudo code of recursive algorithm
%    advantages of scaling particles to fit into [1/2,1]^3
%       exponent if binary expansion is alway 0, no denormalized numbers.
%    some kind of radix sort, bit patterns of coordinates determine the boxes
%       sorting and tree building simultanously
%

