/*
 * FMMV - the Fastest Multipole Method of Vienna
 * Copyright (c) 2006-2015 Harald Hofstaetter
 * http://www.harald-hofstaetter.at
 * 
 * This file is part of FMMV.
 * 
 * FMMV is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * FMMV is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with FMMV; if not, write to the Free Software  Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */

#include<math.h>
#include<stdlib.h>

#include"_fmmv.h"
#ifdef USE_PTHREADS
   #include<pthread.h>
#endif

#define FREE_M(FMMV, x) {FMMV_FREE(FMMV, x, FMM_SIZE_OF_M(FMMV->pM)*sizeof(_FLOAT_)); x=0;}
#define FREE_L(FMMV, x) {FMMV_FREE(FMMV, x, FMM_SIZE_OF_L(FMMV->pL)*sizeof(_FLOAT_)); x=0;}

/* otherNeighbors was generated by the following Python skript: */

#if 0
dim = 2
childs_per_box = 2**dim 
n_other_neighbors = 3**dim-2**dim  

if dim==2:
	childs = [ 'SW', 'NW', 'SE', 'NE']
	neighbors = [ 'SW', 'MW', 'NW', 'SM', 'NM', 'SE', 'ME', 'NE'];
elif dim==3:
	childs_per_box = 8
	n_other_neighbors = 19 
	childs = [ 'SWD', 'NWD', 'SED', 'NED', 'SWU', 'NWU', 'SEU', 'NEU' ]
	neighbors = [ 'SWD', 'MWD', 'NWD', 'SMD', 'MMD', 'NMD', 'SED', 'MED', 'NED',
              'SWM', 'MWM', 'NWM', 'SMM',        'NMM', 'SEM', 'MEM', 'NEM',
              'SWU', 'MWU', 'NWU', 'SMU', 'MMU', 'NMU', 'SEU', 'MEU', 'NEU'];
inv={'S':'N', 'N':'S',
     'E':'W', 'W':'E',
     'D':'U', 'U':'D',
     'M':'M'}

def get_these(c, inverse=True):
	if dim==2:
		a = [c[0] + c[1],	
	  	     'M'  + c[1],	
		     c[0] + 'M',]	
	elif dim==3:
		a = [c[0] + c[1] + c[2],	
  		       'M'  + c[1] + c[2],	
		       c[0] + 'M'  + c[2],	
		       c[0] + c[1] + 'M',	
		       'M'  + 'M'  + c[2],	
     		       'M'  + c[1] + 'M',	
		       c[0] + 'M'  + 'M']	
	if inverse:
		if dim==2:
			return [inv[x[0]]+inv[x[1]] for x in a]
		elif dim==3:
			return [inv[x[0]]+inv[x[1]]+inv[x[2]] for x in a]
	else:	
		return a

i=0		
print 'int otherNeighbors[%i][%i] = {' % (childs_per_box, n_other_neighbors)
for c in childs:
	these = get_these(c)
	others = []
	for n in neighbors:
		if not n in these:
			others.append(n)
	print '{ /* %i %s */ ' % (i, c),
	for n in others:
		print '%s_,' % n,
	print '},'	
	i += 1
print '};'	

i=0		
print '\nint theseParentNeighbors[%i][%i] = {' % (childs_per_box, childs_per_box-1)
for c in childs:
	these = get_these(c, False)
	print '{ /* %i %s */ ' % (i, c),
	for n in these:
		print '%s_,' % n,
	print '},'	
	i += 1
print '};'	
coord={
     'M': 0,
     'S':-1, 'N':1,
     'E':-1, 'W':1,
     'D':-1, 'U':1}

def xxx(c, n):
	r = []
	if dim==2:
	    for x in childs:
		if ( abs(2*coord[n[0]]+coord[x[0]]-coord[c[0]])<=2
		and  abs(2*coord[n[1]]+coord[x[1]]-coord[c[1]])<=2):
			r.append(x)
	elif dim==3:
	    for x in childs:
		if ( abs(2*coord[n[0]]+coord[x[0]]-coord[c[0]])<=2
		and  abs(2*coord[n[1]]+coord[x[1]]-coord[c[1]])<=2
		and  abs(2*coord[n[2]]+coord[x[2]]-coord[c[2]])<=2):
			r.append(x)
	return r
	
i=0

print '\nint otherParentNeighborsChilds[%i][%i][%i] = {' % (childs_per_box, n_other_neighbors, 6)
for c in childs:
	these = get_these(c,False)
	others = []
	for n in neighbors:
		if not n in these:
			others.append(n)
	print '  { /* %i %s */ ' % (i, c)
	for n in others:
		onc = xxx(c, n)
		print '    { %s_, %i,' % (n, len(onc)),
		for m in onc:
			print '%s,' % m,
		print '},'
	print '  },'
	i += 1
print '};'	
#endif


#if (FMM_DIM==2)

#define N_OTHER_NEIGHBORS 5 
int otherNeighbors[FMM_CHILDS_PER_BOX][N_OTHER_NEIGHBORS] = {
{ /* 0 SW */  SW_, MW_, NW_, SM_, SE_, },
{ /* 1 NW */  SW_, MW_, NW_, NM_, NE_, },
{ /* 2 SE */  SW_, SM_, SE_, ME_, NE_, },
{ /* 3 NE */  NW_, NM_, SE_, ME_, NE_, },
};

#elif (FMM_DIM==3)

#define N_OTHER_NEIGHBORS 19
int otherNeighbors[FMM_CHILDS_PER_BOX][N_OTHER_NEIGHBORS] = {
{ /* 0 SWD */  SWD_, MWD_, NWD_, SMD_, MMD_, NMD_, SED_, MED_, NED_, SWM_, MWM_, NWM_, SMM_, SEM_, SWU_, MWU_, NWU_, SMU_, SEU_, },
{ /* 1 NWD */  SWD_, MWD_, NWD_, SMD_, MMD_, NMD_, SED_, MED_, NED_, SWM_, MWM_, NWM_, NMM_, NEM_, SWU_, MWU_, NWU_, NMU_, NEU_, },
{ /* 2 SED */  SWD_, MWD_, NWD_, SMD_, MMD_, NMD_, SED_, MED_, NED_, SWM_, SMM_, SEM_, MEM_, NEM_, SWU_, SMU_, SEU_, MEU_, NEU_, },
{ /* 3 NED */  SWD_, MWD_, NWD_, SMD_, MMD_, NMD_, SED_, MED_, NED_, NWM_, NMM_, SEM_, MEM_, NEM_, NWU_, NMU_, SEU_, MEU_, NEU_, },
{ /* 4 SWU */  SWD_, MWD_, NWD_, SMD_, SED_, SWM_, MWM_, NWM_, SMM_, SEM_, SWU_, MWU_, NWU_, SMU_, MMU_, NMU_, SEU_, MEU_, NEU_, },
{ /* 5 NWU */  SWD_, MWD_, NWD_, NMD_, NED_, SWM_, MWM_, NWM_, NMM_, NEM_, SWU_, MWU_, NWU_, SMU_, MMU_, NMU_, SEU_, MEU_, NEU_, },
{ /* 6 SEU */  SWD_, SMD_, SED_, MED_, NED_, SWM_, SMM_, SEM_, MEM_, NEM_, SWU_, MWU_, NWU_, SMU_, MMU_, NMU_, SEU_, MEU_, NEU_, },
{ /* 7 NEU */  NWD_, NMD_, SED_, MED_, NED_, NWM_, NMM_, SEM_, MEM_, NEM_, SWU_, MWU_, NWU_, SMU_, MMU_, NMU_, SEU_, MEU_, NEU_, },
};

#endif

enum {STANDARD_THREAD=0 ,FARFIELD_THREAD=1, NEARFIELD_THREAD=2};


void* non_adaptive_fmm(GenericFmmThreadArg *arg)
{
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box, *box1;
    int level;
    int i;
    void (*GEN_M)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*EVAL_DIRECT)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }	

    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/
	/* Form multipole expansions at finest level */
	stat_start(FMMV, STAT_GEN_M);	
	if (FMMV->maxLevel>1) {
		for (box=FMMV->firstSourceBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextSourceBox) {
			GEN_M(FMMV, box);
		}
	}
	stat_stop(FMMV, STAT_GEN_M);	

	/* Form multipole expansions at coarser levels by merging */
	stat_start(FMMV, STAT_M2M);	
	init_M2M(FMMV, -1);
	for (level=FMMV->maxLevel-1; level>=2; level--) {
	        init_M2M(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			M2M(FMMV, box);
		}	
	}
	finish_M2M(FMMV);
	stat_stop(FMMV, STAT_M2M);	

	/*** Downward Pass ***/
	stat_start(FMMV, STAT_M2L);	
	init_M2L(FMMV, -1);
	for (level=FMMV->maxLevel; level>=2; level--) {
	/* Convert multipole to exponential expansions and shift exponential expansions */
	        init_M2L(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
			M2L(FMMV, box);
			for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
				if (box->child[i]) FREE_M(FMMV, box->child[i]->M);
			}
		}	
	}
	finish_M2L(FMMV);
	stat_stop(FMMV, STAT_M2L);	

	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);	
	init_L2L(FMMV, -1);
	for (level=3; level<=FMMV->maxLevel; level++) {
	        init_L2L(FMMV, level-1);
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; box!=0; box=box->nextTargetBox) {
			L2L(FMMV, box);
			FREE_L(FMMV, box->L);
		}	
	}	
	finish_L2L(FMMV);
	stat_stop(FMMV, STAT_L2L);	

	/*** Evaluation of Potentials ***/
	stat_start(FMMV, STAT_EVAL_L);	
	if (thread==STANDARD_THREAD) {
		if (FMMV->maxLevel>1) {
			for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
				/* Evaluate local expansions at finest level */
 				EVAL_L(FMMV, box);
				FREE_L(FMMV, box->L);
                	}			
		}
	} /* if (thread==STANDARD_THREAD) */
	#ifdef USE_PTHREADS
	else { /* if (thread==FARFIELD_THREAD) */
		if (FMMV->maxLevel>1) {
			for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
				/* Evaluate local expansions at finest level */
				pthread_mutex_lock(&(box->parent->mutex));
				pthread_mutex_lock(&(box->mutex));
 				EVAL_L(FMMV, box);
				pthread_mutex_unlock(&(box->mutex));
				pthread_mutex_unlock(&(box->parent->mutex));
				FREE_L(FMMV, box->L);
			}	
		}	
	} /* if (thread==FARFIELD_THREAD) */
	#endif   
	stat_stop(FMMV, STAT_EVAL_L);	
   } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */

   if (thread==STANDARD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
#if 0
	for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
	/* Compute near neighbor interactions at finest level directly */
		EVAL_DIRECT(FMMV, box, box);
		for (i=0; i<FMM_NEIGHBORS_PER_BOX; i++) {
			EVAL_DIRECT(FMMV, box, box->neighbor[i]);
		}
	}
#else
	if (FMMV->maxLevel<=1) {	
		box=FMMV->firstTargetBoxOfLevel[0];
		EVAL_DIRECT(FMMV, box, box);
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			EVAL_DIRECT(FMMV, box, box);
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
		    if (isTarget(box)) {
			for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->neighbor[otherNeighbors[box->whichChild][i]];
				EVAL_DIRECT(FMMV, box, box1);
			}
		    }
		}
	}	
#endif	
	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==STANDARD_THREAD) */

#ifdef USE_PTHREADS
   if (thread==NEARFIELD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
#if 0	
	for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
	/* Compute near neighbor interactions at finest level directly */
		pthread_mutex_lock(&(box->mutex));
		EVAL_DIRECT(FMMV, box, box);
		pthread_mutex_unlock(&(box->mutex));
		for (i=0; i<FMM_NEIGHBORS_PER_BOX; i++) {
			pthread_mutex_lock(&(box->neighbor[i]->mutex));
			EVAL_DIRECT(FMMV, box, box->neighbor[i]);
			pthread_mutex_unlock(&(box->neighbor[i]->mutex));
		}
		pthread_mutex_unlock(&(box->mutex));
	}
#else	
	if (FMMV->maxLevel<=1) { /* cannot be locked by EVAL_L, no mutex necessary */	
		box=FMMV->firstTargetBoxOfLevel[0];
		EVAL_DIRECT(FMMV, box, box);
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			EVAL_DIRECT(FMMV, box, box);
			pthread_mutex_unlock(&(box->mutex));
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
		    if (isTarget(box)) {
			pthread_mutex_lock(&(box->mutex));
			if (FMMV->targets) { /* no lock for source boxes */
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->neighbor[otherNeighbors[box->whichChild][i]];
				EVAL_DIRECT(FMMV, box, box1);
			    }
			}    
			else {	
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->neighbor[otherNeighbors[box->whichChild][i]];
				if(box1) {
					pthread_mutex_lock(&(box1->mutex));
					EVAL_DIRECT(FMMV, box, box1);
					pthread_mutex_unlock(&(box1->mutex));
				}
			    }
			}    
			pthread_mutex_unlock(&(box->mutex));
		     }
		}
	}	
#endif	

	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==NEARFIELD_THREAD) */
#endif	
   
   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
}	




#if (FMM_DIM==2)

int boundarysData[] = {
/*  0: SW */ (B_S|B_W),
/*  1: MW */ (    B_W),
/*  2: NW */ (B_N|B_W),
/*  3: SM */ (B_S    ),
/*  4: NM */ (B_N    ),
/*  5: SE */ (B_S|B_E),
/*  6: ME */ (    B_E),
/*  7: NE */ (B_N|B_E),
};

typedef struct {
	_FLOAT_ dx, dy;
} PeriodicShift;

PeriodicShift pS[] = {
/*  0 =  0 | 0 | 0 | 0  */  {  0.0,  0.0 },
/*  1 = B_S| 0 | 0 | 0  */  {  0.0, -1.0 },
/*  2 =  0 |B_N| 0 | 0  */  {  0.0, +1.0 },
/*  3                   */  {  0.0,  0.0 },
/*  4 =  0 | 0 |B_W| 0  */  { -1.0,  0.0 },
/*  5 = B_S| 0 |B_W| 0  */  { -1.0, -1.0 },
/*  6 =  0 |B_N|B_W| 0  */  { -1.0, +1.0 },
/*  7                   */  {  0.0,  0.0 },
/*  8 =  0 | 0 | 0 |B_E */  { +1.0,  0.0 },
/*  9 = B_S| 0 | 0 |B_E */  { +1.0, -1.0 },
/* 10 =  0 |B_N| 0 |B_E */  { +1.0, +1.0 },

/* 11                   */  {  0.0,  0.0 },	
/* 12                   */  {  0.0,  0.0 },
/* 13                   */  {  0.0,  0.0 },
/* 14                   */  {  0.0,  0.0 },
/* 15 = B_S|B_N|B_W|B_E */  {  0.0,  0.0 },
};


#elif (FMM_DIM==3)

int boundarysData[] = {
/*  0: SWD */ (B_S|B_W|B_D),
/*  1: MWD */ (    B_W|B_D),
/*  2: NWD */ (B_N|B_W|B_D),
/*  3: SMD */ (B_S|    B_D),
/*  4: MMD */ (        B_D),
/*  5: NMD */ (B_N|    B_D),
/*  6: SED */ (B_S|B_E|B_D),
/*  7: MED */ (    B_E|B_D),
/*  8: NED */ (B_N|B_E|B_D),
/*  9: SWM */ (B_S|B_W    ),
/* 10: MWM */ (    B_W    ),
/* 11: NWM */ (B_N|B_W    ),
/* 12: SMM */ (B_S        ),
/* 13: NMM */ (B_N        ),
/* 14: SEM */ (B_S|B_E    ),
/* 15: MEM */ (    B_E    ),
/* 16: NEM */ (B_N|B_E    ),
/* 17: SWU */ (B_S|B_W|B_U),
/* 18: MWU */ (    B_W|B_U),
/* 19: NWU */ (B_N|B_W|B_U),
/* 20: SMU */ (B_S|    B_U),
/* 21: MMU */ (        B_U),
/* 22: NMU */ (B_N|    B_U),
/* 23: SEU */ (B_S|B_E|B_U),
/* 24: MEU */ (    B_E|B_U),
/* 25: NEU */ (B_N|B_E|B_U),
};

typedef struct {
	_FLOAT_ dx, dy, dz;
} PeriodicShift;

PeriodicShift pS[] = {
/*  0 =  0 | 0 | 0 | 0 | 0 | 0  */  {  0.0,  0.0,  0.0 },
/*  1 = B_S| 0 | 0 | 0 | 0 | 0  */  {  0.0, -1.0,  0.0 },
/*  2 =  0 |B_N| 0 | 0 | 0 | 0  */  {  0.0, +1.0,  0.0 },
/*  3                           */  {  0.0,  0.0,  0.0 },
/*  4 =  0 | 0 |B_W| 0 | 0 | 0  */  { -1.0,  0.0,  0.0 },
/*  5 = B_S| 0 |B_W| 0 | 0 | 0  */  { -1.0, -1.0,  0.0 },
/*  6 =  0 |B_N|B_W| 0 | 0 | 0  */  { -1.0, +1.0,  0.0 },
/*  7                           */  {  0.0,  0.0,  0.0 },
/*  8 =  0 | 0 | 0 |B_E| 0 | 0  */  { +1.0,  0.0,  0.0 },
/*  9 = B_S| 0 | 0 |B_E| 0 | 0  */  { +1.0, -1.0,  0.0 },
/* 10 =  0 |B_N| 0 |B_E| 0 | 0  */  { +1.0, +1.0,  0.0 },
/* 11                           */  {  0.0,  0.0,  0.0 },	
/* 12                           */  {  0.0,  0.0,  0.0 },
/* 13                           */  {  0.0,  0.0,  0.0 },
/* 14                           */  {  0.0,  0.0,  0.0 },
/* 15                           */  {  0.0,  0.0,  0.0 },
/* 16 =  0 | 0 | 0 | 0 |B_D| 0  */  {  0.0,  0.0, -1.0 },
/* 17 = B_S| 0 | 0 | 0 |B_D| 0  */  {  0.0, -1.0, -1.0 },
/* 18 =  0 |B_N| 0 | 0 |B_D| 0  */  {  0.0, +1.0, -1.0 },
/* 19                           */  {  0.0,  0.0,  0.0 },
/* 20 =  0 | 0 |B_W| 0 |B_D| 0  */  { -1.0,  0.0, -1.0 },
/* 21 = B_S| 0 |B_W| 0 |B_D| 0  */  { -1.0, -1.0, -1.0 },
/* 22 =  0 |B_N|B_W| 0 |B_D| 0  */  { -1.0, +1.0, -1.0 },
/* 23                           */  {  0.0,  0.0,  0.0 }, 
/* 24 =  0 | 0 | 0 |B_E|B_D| 0  */  { +1.0,  0.0, -1.0 },
/* 25 = B_S| 0 | 0 |B_E|B_D| 0  */  { +1.0, -1.0, -1.0 },
/* 26 =  0 |B_N| 0 |B_E|B_D| 0  */  { +1.0, +1.0, -1.0 },	
/* 27                           */  {  0.0,  0.0,  0.0 },                      
/* 28                           */  {  0.0,  0.0,  0.0 },                         
/* 29                           */  {  0.0,  0.0,  0.0 },                         
/* 30                           */  {  0.0,  0.0,  0.0 },                         
/* 21                           */  {  0.0,  0.0,  0.0 },                         
/* 32 =  0 | 0 | 0 | 0 | 0 |B_U */  {  0.0,  0.0, +1.0 },
/* 33 = B_S| 0 | 0 | 0 | 0 |B_U */  {  0.0, -1.0, +1.0 },
/* 34 =  0 |B_N| 0 | 0 | 0 |B_U */  {  0.0, +1.0, +1.0 },
/* 35                           */  {  0.0,  0.0,  0.0 },
/* 36 =  0 | 0 |B_W| 0 | 0 |B_U */  { -1.0,  0.0, +1.0 },
/* 37 = B_S| 0 |B_W| 0 | 0 |B_U */  { -1.0, -1.0, +1.0 },
/* 38 =  0 |B_N|B_W| 0 | 0 |B_U */  { -1.0, +1.0, +1.0 },
/* 39                           */  {  0.0,  0.0,  0.0 },
/* 40 =  0 | 0 | 0 |B_E| 0 |B_U */  { +1.0,  0.0, +1.0 },
/* 41 = B_S| 0 | 0 |B_E| 0 |B_U */  { +1.0, -1.0, +1.0 },
/* 42 =  0 |B_N| 0 |B_E| 0 |B_U */  { +1.0, +1.0, +1.0 },	
/* 43                           */  {  0.0,  0.0,  0.0 },                        
/* 44                           */  {  0.0,  0.0,  0.0 },                         
/* 45                           */  {  0.0,  0.0,  0.0 },                         
/* 46                           */  {  0.0,  0.0,  0.0 },                         
/* 47                           */  {  0.0,  0.0,  0.0 },                         
/* 48                           */  {  0.0,  0.0,  0.0 },                         
/* 49                           */  {  0.0,  0.0,  0.0 },                         
/* 50                           */  {  0.0,  0.0,  0.0 },                         
/* 51                           */  {  0.0,  0.0,  0.0 },                         
/* 52                           */  {  0.0,  0.0,  0.0 },                         
/* 53                           */  {  0.0,  0.0,  0.0 },                         
/* 54                           */  {  0.0,  0.0,  0.0 },                         
/* 55                           */  {  0.0,  0.0,  0.0 },                         
/* 56                           */  {  0.0,  0.0,  0.0 },                         
/* 57                           */  {  0.0,  0.0,  0.0 },                         
/* 58                           */  {  0.0,  0.0,  0.0 },                         
/* 59                           */  {  0.0,  0.0,  0.0 },                         
/* 60                           */  {  0.0,  0.0,  0.0 },                         
/* 61                           */  {  0.0,  0.0,  0.0 },                         
/* 62                           */  {  0.0,  0.0,  0.0 },                         
/* 63 = B_S|B_N|B_W|B_E|B_D|B_U */  {  0.0,  0.0,  0.0 },
};

#endif


void* non_adaptive_fmm_periodic(GenericFmmThreadArg *arg)
{
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box;
    int level;
    int i, j, k;
    void (*GEN_M)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*EVAL_DIRECT)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;
    void (*EVAL_DIRECT_periodic)(FmmvHandle *FMMV, Box *target, Box *source, _FLOAT_ dx, _FLOAT_ dy
	#if (FMM_DIM>=3)
	, _FLOAT_ dz
	#endif	    
        ) = FMMV->eval_direct_periodic;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }

    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/
	/* Form multipole expansions at finest level */
	stat_start(FMMV, STAT_GEN_M);	
	for (box=FMMV->firstSourceBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextSourceBox) {
		GEN_M(FMMV, box);
	}
	stat_stop(FMMV, STAT_GEN_M);	
	
	/* Form multipole expansions at coarser levels by merging */
	stat_start(FMMV, STAT_M2M);
        init_M2M(FMMV, -1);	
	for (level=FMMV->maxLevel-1; level>=0; level--) { /* note: now compute M up to level 0 */
                init_M2M(FMMV, level);	
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			M2M(FMMV, box);
		}	
	}
        finish_M2M(FMMV);	
	stat_stop(FMMV, STAT_M2M);	
	
	/*** Downward Pass ***/
	stat_start(FMMV, STAT_M2L);	
        init_M2L(FMMV, -1);	

#if 1	
	/******************************************************************/
	FMMV->firstSourceBoxOfLevel[0]->L = (_FLOAT_ *) FMMV_MALLOC(FMMV, FMM_SIZE_OF_L(FMMV->pL)*sizeof(_FLOAT_));

#ifdef USE_PTHREADS
	if (thread==FARFIELD_THREAD) {
		pthread_mutex_lock(&(FMMV->firstSourceBoxOfLevel[0]->mutex));
	}
#endif	
	
	periodic_lattice_M2L(FMMV, FMMV->firstSourceBoxOfLevel[0]->M, FMMV->firstSourceBoxOfLevel[0]->L);

#ifdef USE_PTHREADS
	if (thread==FARFIELD_THREAD) {
		pthread_mutex_unlock(&(FMMV->firstSourceBoxOfLevel[0]->mutex));
	}
#endif	
	FREE_M(FMMV, FMMV->firstSourceBoxOfLevel[0]->M);
	/******************************************************************/
#endif
	for (level=1; level<=FMMV->maxLevel; level++) {
	/* Convert multipole to exponential expansions and shift exponential expansions */
                init_M2L(FMMV, level);	
		for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
			M2L(FMMV, box);
			for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
				if (box->child[i]) {
					FREE_M(FMMV, box->child[i]->M);
				}
			}
		}	
	} /* Note: loop should be fused with next one */
        finish_M2L(FMMV);	
	stat_stop(FMMV, STAT_M2L);	

	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);	
        init_L2L(FMMV, -1);	
	for (level=1; level<=FMMV->maxLevel; level++) {
                init_L2L(FMMV, level-1);	
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; box!=0; box=box->nextTargetBox) {
			L2L(FMMV, box);
			FREE_L(FMMV, box->L);
		}	
	}
        finish_L2L(FMMV);	
	stat_stop(FMMV, STAT_L2L);	
	
	/*** Evaluation of Potentials ***/
	stat_start(FMMV, STAT_EVAL_L);	
	if (thread==STANDARD_THREAD) {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			/* Evaluate local expansions at finest level */
	 		EVAL_L(FMMV, box);
			FREE_L(FMMV, box->L);
		}
	} /* if (thread==STANDARD_THREAD) */
#ifdef USE_PTHREADS
	else { /* if (thread==FARFIELD_THREAD) */
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			/* Evaluate local expansions at finest level */
			pthread_mutex_lock(&(box->mutex));
	 		EVAL_L(FMMV, box);
			pthread_mutex_unlock(&(box->mutex));
			FREE_L(FMMV, box->L);
		}
	}
#endif	

	stat_stop(FMMV, STAT_EVAL_L);	
    } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */
    if (thread==STANDARD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel==0) {	
		int dx, dy;
		#if (FMM_DIM>=3)
		int dz;
		#endif
		box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel];
		EVAL_DIRECT(FMMV, box, box);
		for (dx=-1; dx<=+1; dx++) {
		for (dy=-1; dy<=+1; dy++) {
		#if (FMM_DIM>=3)
		for (dz=-1; dz<=+1; dz++) {
		#endif
			if (!((dx==0)&&(dy==0)
				#if (FMM_DIM>=3)
				&&(dz==0)
				#endif
				)) {
		    		EVAL_DIRECT_periodic(FMMV, box, box, dx, dy
					#if (FMM_DIM>=3)
					, dz
					#endif
					);
			}
		#if (FMM_DIM>=3)
		}
		#endif
		}}	
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			EVAL_DIRECT(FMMV, box, box);
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				if (box->neighbor[k=otherNeighbors[box->whichChild][i]]) {
					j=((box->atBoundary) & (boundarysData[k]));
			    		EVAL_DIRECT_periodic(FMMV, box, box->neighbor[k], pS[j].dx, pS[j].dy
						#if (FMM_DIM>=3)
						, pS[j].dz
						#endif
						);
				}
			}
		}
	}	
	stat_stop(FMMV, STAT_LIST1);	
    } /* if (thread==STANDARD_THREAD) */

#ifdef USE_PTHREADS
    if (thread==NEARFIELD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel==0) {	
		int dx, dy;
		#if (FMM_DIM>=3)
		int dz;
		#endif
		box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel];
		pthread_mutex_lock(&(box->mutex));
		EVAL_DIRECT(FMMV, box, box);
		for (dx=-1; dx<=+1; dx++) {
		for (dy=-1; dy<=+1; dy++) {
		#if (FMM_DIM>=3)
		for (dz=-1; dz<=+1; dz++) {
		#endif
			if (!((dx==0)&&(dy==0)
				#if (FMM_DIM>=3)
				&&(dz==0)
				#endif
				)) {
		    		EVAL_DIRECT_periodic(FMMV, box, box, dx, dy
					#if (FMM_DIM>=3)
					, dz
					#endif
					);
			}
		#if (FMM_DIM>=3)
		}
		#endif
		}}	
		pthread_mutex_unlock(&(box->mutex));
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			EVAL_DIRECT(FMMV, box, box);
			pthread_mutex_unlock(&(box->mutex));
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
		    if (isTarget(box)) {
			pthread_mutex_lock(&(box->mutex));
			if (FMMV->targets) { /* no lock for source boxes */
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				if (box->neighbor[k=otherNeighbors[box->whichChild][i]]) {
					j=((box->atBoundary) & (boundarysData[k]));
			    		EVAL_DIRECT_periodic(FMMV, box, box->neighbor[k], pS[j].dx, pS[j].dy
						#if (FMM_DIM>=3)
						, pS[j].dz
						#endif
						);
				}
			    }	
			}
			else {	
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				if (box->neighbor[k=otherNeighbors[box->whichChild][i]]) {
					j=((box->atBoundary) & (boundarysData[k]));
					pthread_mutex_lock(&(box->neighbor[k]->mutex));
			    		EVAL_DIRECT_periodic(FMMV, box, box->neighbor[k], pS[j].dx, pS[j].dy
						#if (FMM_DIM>=3)
						, pS[j].dz
						#endif
						);
					pthread_mutex_unlock(&(box->neighbor[k]->mutex));
				}
			    }	
			}
			pthread_mutex_unlock(&(box->mutex));
		     }
		}
	}	
	stat_stop(FMMV, STAT_LIST1);	
    } /* if (thread==NEARFIELD_THREAD) */
#endif    

   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
}	


void* adaptive_fmm(GenericFmmThreadArg *arg)
{
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box;
    Box **LIST;
    int listSize;
    int i, j;
    int level;
    void (*GEN_M)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*GEN_L_EVAL_M)(FmmvHandle *FMMV, Box *list3, Box *list4) = FMMV->gen_L_eval_M;
    void (*EVAL_DIRECT)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }	

    LIST = (Box**) FMMV_MALLOC(FMMV, FMMV->statistics.noOfSourceBoxes*sizeof(Box*));
    if (!LIST) return 0; /* TODO: better error handling, better estimate of max size of lists */

    if (FMMV->directEvalThreshold<0) {
	FMMV->directEvalThreshold = FMMV->pM*FMMV->pM;
    }	

    /* potential and gradient should be initialized to zero */

    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/	
	/* Form multipole expansion for each childless box */
	stat_start(FMMV, STAT_GEN_M);	
	for (level=2; level<=FMMV->maxLevel; level++) {
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			if (isChildless(box)) {
				GEN_M(FMMV, box);
			}
		}
	}	
	stat_stop(FMMV, STAT_GEN_M);	

	/* Merge multipole expansions of children for each parent box */
	stat_start(FMMV, STAT_M2M);	
	init_M2M(FMMV, -1);
	for (level=FMMV->maxLevel-1; level>=2; level--) {
	        init_M2M(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			if (!isChildless(box)) {
				M2M(FMMV, box);
			}	
		}	
	}
	finish_M2M(FMMV);
	stat_stop(FMMV, STAT_M2M);	

	/*** M2L Pass ***/
	stat_start(FMMV, STAT_M2L);	
	init_M2L(FMMV, -1);
	for (level=2; level<=FMMV->maxLevel; level++) {
	/* Convert multipole to exponential expansions and shift exponential expansions */
	        init_M2L(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
			M2L(FMMV, box);
    			if (thread==STANDARD_THREAD) { 
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) {
						genList4(box->child[i], LIST, &listSize);
						if (box->child[i]->noOfParticles > FMMV->directEvalThreshold) {	
							for (j=0; j<listSize; j++) {
								GEN_L_EVAL_M(FMMV, box->child[i], LIST[j]);
								//GEN_L(FMMV, box->child[i], LIST[j]);
								//EVAL_M(FMMV, LIST[j], box->child[i]);
							}
						}	
						else {
						
							for (j=0; j<listSize; j++) {
								if (box->child[i]->firstParticle>LIST[j]->firstParticle) {
									EVAL_DIRECT(FMMV, LIST[j], box->child[i]);
								}
								else {
									EVAL_DIRECT(FMMV, box->child[i], LIST[j]);
								}	
							}
						}	
						FREE_M(FMMV, box->child[i]->M);
					}
				}
			}
#ifdef USE_PTHREADS
    			else { /* FARFIELD_THREAD */
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) {
						genList4(box->child[i], LIST, &listSize);
						pthread_mutex_lock(&(box->child[i]->mutex));
						if (box->child[i]->noOfParticles > FMMV->directEvalThreshold) {	
							for (j=0; j<listSize; j++) {
								pthread_mutex_lock(&(LIST[j]->mutex));
								GEN_L_EVAL_M(FMMV, box->child[i], LIST[j]);
								//GEN_L(FMMV, box->child[i], LIST[j]);
								//EVAL_M(FMMV, LIST[j], box->child[i]);
								pthread_mutex_unlock(&(LIST[j]->mutex));
							}
						}	
						else {
							for (j=0; j<listSize; j++) {
								pthread_mutex_lock(&(LIST[j]->mutex));
								if (box->child[i]->firstParticle>LIST[j]->firstParticle) {
									EVAL_DIRECT(FMMV, LIST[j], box->child[i]);
								}
								else {
									EVAL_DIRECT(FMMV, box->child[i], LIST[j]);
								}	
								pthread_mutex_unlock(&(LIST[j]->mutex));
							}
						}	
						pthread_mutex_unlock(&(box->child[i]->mutex));
						FREE_M(FMMV, box->child[i]->M);
					}
				}
			}
#endif			
		}	
	}
        finish_M2L(FMMV);	
	stat_stop(FMMV, STAT_M2L);	


	/*** Downward Pass ***/	
	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);	
	init_L2L(FMMV, -1);
	for (level=3; level<=FMMV->maxLevel; level++) {
	        init_L2L(FMMV, level-1);
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; 
		     box!=0; box=box->nextTargetBox) {
			if (!isChildless(box)) {
				L2L(FMMV, box);
				FREE_L(FMMV, box->L);
			}	
		}	
	}		
	finish_L2L(FMMV);
	stat_stop(FMMV, STAT_L2L);	

	/*** Evaluation of Potentials ***/
	/* Evaluate local expansion */
	stat_start(FMMV, STAT_EVAL_L);	
    	if (thread==STANDARD_THREAD) {
		for (level=0; level<=FMMV->maxLevel; level++) {
			for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
				if (isChildless(box)) {
		 			EVAL_L(FMMV, box);
					FREE_L(FMMV, box->L);
				}
			}
		}	
	}
#ifdef USE_PTHREADS
	else { /* FARFIELD_THREAD */
		for (level=0; level<=FMMV->maxLevel; level++) {
			for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
				if (isChildless(box)) {
					pthread_mutex_lock(&(box->mutex));
		 			EVAL_L(FMMV, box);
					pthread_mutex_unlock(&(box->mutex));
					FREE_L(FMMV, box->L);
				}
			}
		}	
	}
#endif	
	stat_stop(FMMV, STAT_EVAL_L);	
    } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */

    if (thread==STANDARD_THREAD) {
	/* Compute interactions due to charges in List 1 directly */
	stat_start(FMMV, STAT_LIST1);	
	for (level=0; level<=FMMV->maxLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (isChildless(box)) {
				EVAL_DIRECT(FMMV, box, box);
				genList1(box, LIST, &listSize);
				for (i=0; i<listSize; i++) {
					EVAL_DIRECT(FMMV, box, LIST[i]);
				}
			}
		}
	}	
	stat_stop(FMMV, STAT_LIST1);	
    } /* if (thread==STANDARD_THREAD) */

#ifdef USE_PTHREADS
    if (thread==NEARFIELD_THREAD) {
	/* Compute interactions due to charges in List 1 directly */
	stat_start(FMMV, STAT_LIST1);	
	for (level=0; level<=FMMV->maxLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (isChildless(box)) {
				genList1(box, LIST, &listSize);
				pthread_mutex_lock(&(box->mutex));
				if (FMMV->targets) { /* no lock for source boxes */
					EVAL_DIRECT(FMMV, box, box);
					for (i=0; i<listSize; i++) {
						EVAL_DIRECT(FMMV, box, LIST[i]);
					}
				}
				else {	
					EVAL_DIRECT(FMMV, box, box);
					for (i=0; i<listSize; i++) {
						pthread_mutex_lock(&(LIST[i]->mutex));
						EVAL_DIRECT(FMMV, box, LIST[i]);
						pthread_mutex_unlock(&(LIST[i]->mutex));
					}
				}
				pthread_mutex_unlock(&(box->mutex));
			}
		}
	}	
	stat_stop(FMMV, STAT_LIST1);	
    } /* if (thread==NEARFIELD_THREAD) */
#endif    
   FMMV_FREE(FMMV, LIST, FMMV->statistics.noOfSourceBoxes*sizeof(Box*)); 

   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
}	

/******************************************************************/

void* adaptive_fmm_ST(GenericFmmThreadArg *arg)
{
#ifdef USE_PTHREADS
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box;
    Box **LIST;
    int listSize, maxListSize;
    int i;
    int level;
    void (*GEN_M_ST)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L_ST)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*GEN_L_ST)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->gen_L;
    void (*EVAL_M_ST)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_M;
    void (*EVAL_DIRECT_ST)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }	

   
    maxListSize = (FMMV->statistics.noOfSourceBoxes>FMMV->statistics.noOfTargetBoxes?FMMV->statistics.noOfSourceBoxes:FMMV->statistics.noOfTargetBoxes);
    LIST = (Box**) FMMV_MALLOC(FMMV, maxListSize*sizeof(Box*));
    if (!LIST) return 0; /* TODO: better error handling, better estimate of max size of lists */
    
    if (FMMV->directEvalThreshold<0) {
	    FMMV->directEvalThreshold = FMMV->pM*FMMV->pM;
    }	

    /* potential and gradient should be initialized to zero */

    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/	
	/* Form multipole expansion for each childless box */
	stat_start(FMMV, STAT_GEN_M);
	for (level=2; level<=FMMV->maxLevel; level++) {
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			if (isChildlessSource(box)) {
				GEN_M_ST(FMMV, box);
			}
		}
	}	
	stat_stop(FMMV, STAT_GEN_M);

	/* Merge multipole expansions of children for each parent box */
	stat_start(FMMV, STAT_M2M);
	init_M2M(FMMV, -1);
	for (level=FMMV->maxLevel-1; level>=2; level--) {
	        init_M2M(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			if (hasSourceChilds(box)) {
				M2M(FMMV, box);
			}	
		}	
	}
	finish_M2M(FMMV);
	stat_stop(FMMV, STAT_M2M);

	stat_start(FMMV, STAT_LIST3);
	for (level=1; level<=FMMV->maxTargetLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (!hasTargetChilds(box)) {
	/* Evaluate multipole expansion of each box in List 3 */
				genList3_ST(box, LIST, &listSize);
				for (i=0; i<listSize; i++) {
					if (LIST[i]->noOfTargets <= FMMV->directEvalThreshold) {
					    if (thread==STANDARD_THREAD) {
						    EVAL_DIRECT_ST(FMMV, box, LIST[i]);
					    }
					}
					else {
						EVAL_M_ST(FMMV, box, LIST[i]);
					}	
				}
			}
		}
	}	
	stat_stop(FMMV, STAT_LIST3);
	

	/*** M2L Pass ***/
	stat_start(FMMV, STAT_M2L);
	init_M2L(FMMV, -1);
	for (level=2; level<=(FMMV->maxLevel<=FMMV->maxTargetLevel?FMMV->maxLevel:FMMV->maxTargetLevel); level++) {
	/* Convert multipole to exponential expansions and shift exponential expansions */
	        init_M2L(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
			M2L(FMMV, box);
			for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
				if (box->child[i]) {
						FREE_M(FMMV, box->child[i]->M);
				}
			}
		}	
	}
	for (level=FMMV->maxTargetLevel+1; level<=FMMV->maxLevel; level++) {
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			FREE_M(FMMV, box->M);
		}
	}
	finish_M2L(FMMV);
	stat_stop(FMMV, STAT_M2L);

		
	stat_start(FMMV, STAT_LIST4);
	for (level=2; level<=FMMV->maxTargetLevel; level++) {	
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
		/* Create local expansions due to to all charges in List 4 */
			if (box->noOfTargets <= FMMV->directEvalThreshold) {	
			    if (thread==STANDARD_THREAD) {
				    genList4_ST(box, LIST, &listSize);
				    for (i=0; i<listSize; i++) {
				       	    EVAL_DIRECT_ST(FMMV, box, LIST[i]);
				    }
			    }	
			}	
			else {
				genList4_ST(box, LIST, &listSize);
				for (i=0; i<listSize; i++) {
					GEN_L_ST(FMMV, box, LIST[i]);
				}
			}	
		}
	}
	stat_stop(FMMV, STAT_LIST4);
	
	/*** Downward Pass ***/	
	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);
	init_L2L(FMMV, -1);
	for (level=3; level<=FMMV->maxTargetLevel; level++) {
	        init_L2L(FMMV, level-1);
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; box!=0; box=box->nextTargetBox) {
			if (hasTargetChilds(box)) {
				L2L(FMMV, box);
				FREE_L(FMMV, box->L)
			}	
		}	
	}
	finish_L2L(FMMV);
	stat_stop(FMMV, STAT_L2L);
	
	/*** Evaluation of Potentials ***/
	/* Evaluate local expansion */
        if (thread==FARFIELD_THREAD) {
		stat_start(FMMV, STAT_EVAL_L);	
		for (level=0; level<=FMMV->maxTargetLevel; level++) {
			for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
				if (!hasTargetChilds(box)) {
					if (level>=1) {
			 			EVAL_L_ST(FMMV, box);
						FREE_L(FMMV, box->L)
					}	
				}
			}
		}
	}	
	else { /* STANDARD_THREAD */
		stat_start(FMMV, STAT_EVAL_L);	
		for (level=0; level<=FMMV->maxTargetLevel; level++) {
			for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
				if (!hasTargetChilds(box)) {
					if (level>=1) {
			 			EVAL_L_ST(FMMV, box);
						FREE_L(FMMV, box->L)
					}	
				}
			}
		}
	}
	stat_stop(FMMV, STAT_EVAL_L);
    } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */
	
    if (thread==STANDARD_THREAD) {
	/* Compute interactions due to charges in List 1 directly */
	stat_start(FMMV, STAT_LIST1);
	for (level=0; level<=FMMV->maxTargetLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (!hasTargetChilds(box)) {
				genList1_ST(box, LIST, &listSize);
				for (i=0; i<listSize; i++) {
					EVAL_DIRECT_ST(FMMV, box, LIST[i]);
				}
			}
		}
	}
	stat_stop(FMMV, STAT_LIST1);
    } /* if (thread==STANDARD_THREAD) */

    if (thread==NEARFIELD_THREAD) {
	/* Compute interactions due to charges in List 1 directly */
	stat_start(FMMV, STAT_LIST1);
	for (level=0; level<=FMMV->maxTargetLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (!hasTargetChilds(box)) {
				genList1_ST(box, LIST, &listSize);
				pthread_mutex_lock(&(box->mutex));
				for (i=0; i<listSize; i++) {
					EVAL_DIRECT_ST(FMMV, box, LIST[i]);
				}
				pthread_mutex_unlock(&(box->mutex));
			}
		}
	}

	for (level=1; level<=FMMV->maxTargetLevel; level++) {
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
			if (!hasTargetChilds(box)) {
	    /* Evaluate multipole expansion of each box in List 3 */
				genList3_ST(box, LIST, &listSize);
				pthread_mutex_lock(&(box->mutex));
				for (i=0; i<listSize; i++) {
					if (LIST[i]->noOfTargets <= FMMV->directEvalThreshold) {
						EVAL_DIRECT_ST(FMMV, box, LIST[i]);
					}
				}
				pthread_mutex_unlock(&(box->mutex));
			}
		}
	}	
		
	for (level=2; level<=FMMV->maxTargetLevel; level++) {	
		for (box=FMMV->firstTargetBoxOfLevel[level]; box!=0; box=box->nextTargetBox) {
		/* Create local expansions due to to all charges in List 4 */
			if (box->noOfTargets <= FMMV->directEvalThreshold) {	
				genList4_ST(box, LIST, &listSize);
				pthread_mutex_lock(&(box->mutex));
				for (i=0; i<listSize; i++) {
					EVAL_DIRECT_ST(FMMV, box, LIST[i]);
				}
				pthread_mutex_unlock(&(box->mutex));
			}	
		}
	}
	stat_stop(FMMV, STAT_LIST1);
   } /* if (thread==NEARFIELD_THREAD) */
   FMMV_FREE(FMMV, LIST, maxListSize*sizeof(Box*)); 

   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
#endif
}	


