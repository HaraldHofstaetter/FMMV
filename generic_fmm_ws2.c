/*
 * FMMV - the Fastest Multipole Method of Vienna
 * Copyright (c) 2006-2010 Harald Hofstaetter
 * Institute of Mathematics
 * University of Vienna
 * 
 * This file is part of FMMV.
 * 
 * FMMV is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * FMMV is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with FMMV; if not, write to the Free Software  Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */


#include<math.h>
#include<stdlib.h>

#include"_fmmv.h"
#ifdef USE_PTHREADS
   #include<pthread.h>
#endif


#define FREE_M(FMMV, x) {FMMV_FREE(FMMV, x, FMM_SIZE_OF_M(FMMV->pM)*sizeof(_FLOAT_)); x=0;}
#define FREE_L(FMMV, x) {FMMV_FREE(FMMV, x, FMM_SIZE_OF_L(FMMV->pL)*sizeof(_FLOAT_)); x=0;}

#if (FMM_DIM==2)
#define N_OTHER_NEIGHBORS 5 
#elif (FMM_DIM==3)
#define N_OTHER_NEIGHBORS 19
#endif

/* theseParentNeighbors and otherParentNeighborsChilds were generated by
 * the Python skript in generic_fmm.c
 */
#if (FMM_DIM==2)

#define N_OTHER_NEIGHBORS 5 
 
int theseParentNeighbors[4][3] = {
{ /* 0 SW */  SW_, MW_, SM_, },
{ /* 1 NW */  NW_, MW_, NM_, },
{ /* 2 SE */  SE_, ME_, SM_, },
{ /* 3 NE */  NE_, ME_, NM_, },
};

int otherParentNeighborsChilds[FMM_CHILDS_PER_BOX][N_OTHER_NEIGHBORS][4] = {
  { /* 0 SW */
    { NW_, 2, SW, SE, },
    { NM_, 2, SW, SE, },
    { SE_, 2, SW, NW, },
    { ME_, 2, SW, NW, },
    { NE_, 1, SW, },
  },
  { /* 1 NW */
    { SW_, 2, NW, NE, },
    { SM_, 2, NW, NE, },
    { SE_, 1, NW, },
    { ME_, 2, SW, NW, },
    { NE_, 2, SW, NW, },
  },
  { /* 2 SE */
    { SW_, 2, SE, NE, },
    { MW_, 2, SE, NE, },
    { NW_, 1, SE, },
    { NM_, 2, SW, SE, },
    { NE_, 2, SW, SE, },
  },
  { /* 3 NE */
    { SW_, 1, NE, },
    { MW_, 2, SE, NE, },
    { NW_, 2, SE, NE, },
    { SM_, 2, NW, NE, },
    { SE_, 2, NW, NE, },
  },
};

#elif (FMM_DIM==3)

#define N_OTHER_NEIGHBORS 19
	
int theseParentNeighbors[FMM_CHILDS_PER_BOX][FMM_CHILDS_PER_BOX-1] = {
{ /* 0 SWD */  SWD_, MWD_, SMD_, SWM_, MMD_, MWM_, SMM_, },
{ /* 1 NWD */  NWD_, MWD_, NMD_, NWM_, MMD_, MWM_, NMM_, },
{ /* 2 SED */  SED_, MED_, SMD_, SEM_, MMD_, MEM_, SMM_, },
{ /* 3 NED */  NED_, MED_, NMD_, NEM_, MMD_, MEM_, NMM_, },
{ /* 4 SWU */  SWU_, MWU_, SMU_, SWM_, MMU_, MWM_, SMM_, },
{ /* 5 NWU */  NWU_, MWU_, NMU_, NWM_, MMU_, MWM_, NMM_, },
{ /* 6 SEU */  SEU_, MEU_, SMU_, SEM_, MMU_, MEM_, SMM_, },
{ /* 7 NEU */  NEU_, MEU_, NMU_, NEM_, MMU_, MEM_, NMM_, },
};

int otherParentNeighborsChilds[FMM_CHILDS_PER_BOX][N_OTHER_NEIGHBORS][6] = {
  { /* 0 SWD */ 
    { NWD_, 4, SWD, SED, SWU, SEU, },
    { NMD_, 4, SWD, SED, SWU, SEU, },
    { SED_, 4, SWD, NWD, SWU, NWU, },
    { MED_, 4, SWD, NWD, SWU, NWU, },
    { NED_, 2, SWD, SWU, },
    { NWM_, 4, SWD, SED, SWU, SEU, },
    { NMM_, 4, SWD, SED, SWU, SEU, },
    { SEM_, 4, SWD, NWD, SWU, NWU, },
    { MEM_, 4, SWD, NWD, SWU, NWU, },
    { NEM_, 2, SWD, SWU, },
    { SWU_, 4, SWD, NWD, SED, NED, },
    { MWU_, 4, SWD, NWD, SED, NED, },
    { NWU_, 2, SWD, SED, },
    { SMU_, 4, SWD, NWD, SED, NED, },
    { MMU_, 4, SWD, NWD, SED, NED, },
    { NMU_, 2, SWD, SED, },
    { SEU_, 2, SWD, NWD, },
    { MEU_, 2, SWD, NWD, },
    { NEU_, 1, SWD, },
  },
  { /* 1 NWD */ 
    { SWD_, 4, NWD, NED, NWU, NEU, },
    { SMD_, 4, NWD, NED, NWU, NEU, },
    { SED_, 2, NWD, NWU, },
    { MED_, 4, SWD, NWD, SWU, NWU, },
    { NED_, 4, SWD, NWD, SWU, NWU, },
    { SWM_, 4, NWD, NED, NWU, NEU, },
    { SMM_, 4, NWD, NED, NWU, NEU, },
    { SEM_, 2, NWD, NWU, },
    { MEM_, 4, SWD, NWD, SWU, NWU, },
    { NEM_, 4, SWD, NWD, SWU, NWU, },
    { SWU_, 2, NWD, NED, },
    { MWU_, 4, SWD, NWD, SED, NED, },
    { NWU_, 4, SWD, NWD, SED, NED, },
    { SMU_, 2, NWD, NED, },
    { MMU_, 4, SWD, NWD, SED, NED, },
    { NMU_, 4, SWD, NWD, SED, NED, },
    { SEU_, 1, NWD, },
    { MEU_, 2, SWD, NWD, },
    { NEU_, 2, SWD, NWD, },
  },
  { /* 2 SED */ 
    { SWD_, 4, SED, NED, SEU, NEU, },
    { MWD_, 4, SED, NED, SEU, NEU, },
    { NWD_, 2, SED, SEU, },
    { NMD_, 4, SWD, SED, SWU, SEU, },
    { NED_, 4, SWD, SED, SWU, SEU, },
    { SWM_, 4, SED, NED, SEU, NEU, },
    { MWM_, 4, SED, NED, SEU, NEU, },
    { NWM_, 2, SED, SEU, },
    { NMM_, 4, SWD, SED, SWU, SEU, },
    { NEM_, 4, SWD, SED, SWU, SEU, },
    { SWU_, 2, SED, NED, },
    { MWU_, 2, SED, NED, },
    { NWU_, 1, SED, },
    { SMU_, 4, SWD, NWD, SED, NED, },
    { MMU_, 4, SWD, NWD, SED, NED, },
    { NMU_, 2, SWD, SED, },
    { SEU_, 4, SWD, NWD, SED, NED, },
    { MEU_, 4, SWD, NWD, SED, NED, },
    { NEU_, 2, SWD, SED, },
  },
  { /* 3 NED */ 
    { SWD_, 2, NED, NEU, },
    { MWD_, 4, SED, NED, SEU, NEU, },
    { NWD_, 4, SED, NED, SEU, NEU, },
    { SMD_, 4, NWD, NED, NWU, NEU, },
    { SED_, 4, NWD, NED, NWU, NEU, },
    { SWM_, 2, NED, NEU, },
    { MWM_, 4, SED, NED, SEU, NEU, },
    { NWM_, 4, SED, NED, SEU, NEU, },
    { SMM_, 4, NWD, NED, NWU, NEU, },
    { SEM_, 4, NWD, NED, NWU, NEU, },
    { SWU_, 1, NED, },
    { MWU_, 2, SED, NED, },
    { NWU_, 2, SED, NED, },
    { SMU_, 2, NWD, NED, },
    { MMU_, 4, SWD, NWD, SED, NED, },
    { NMU_, 4, SWD, NWD, SED, NED, },
    { SEU_, 2, NWD, NED, },
    { MEU_, 4, SWD, NWD, SED, NED, },
    { NEU_, 4, SWD, NWD, SED, NED, },
  },
  { /* 4 SWU */ 
    { SWD_, 4, SWU, NWU, SEU, NEU, },
    { MWD_, 4, SWU, NWU, SEU, NEU, },
    { NWD_, 2, SWU, SEU, },
    { SMD_, 4, SWU, NWU, SEU, NEU, },
    { MMD_, 4, SWU, NWU, SEU, NEU, },
    { NMD_, 2, SWU, SEU, },
    { SED_, 2, SWU, NWU, },
    { MED_, 2, SWU, NWU, },
    { NED_, 1, SWU, },
    { NWM_, 4, SWD, SED, SWU, SEU, },
    { NMM_, 4, SWD, SED, SWU, SEU, },
    { SEM_, 4, SWD, NWD, SWU, NWU, },
    { MEM_, 4, SWD, NWD, SWU, NWU, },
    { NEM_, 2, SWD, SWU, },
    { NWU_, 4, SWD, SED, SWU, SEU, },
    { NMU_, 4, SWD, SED, SWU, SEU, },
    { SEU_, 4, SWD, NWD, SWU, NWU, },
    { MEU_, 4, SWD, NWD, SWU, NWU, },
    { NEU_, 2, SWD, SWU, },
  },
  { /* 5 NWU */ 
    { SWD_, 2, NWU, NEU, },
    { MWD_, 4, SWU, NWU, SEU, NEU, },
    { NWD_, 4, SWU, NWU, SEU, NEU, },
    { SMD_, 2, NWU, NEU, },
    { MMD_, 4, SWU, NWU, SEU, NEU, },
    { NMD_, 4, SWU, NWU, SEU, NEU, },
    { SED_, 1, NWU, },
    { MED_, 2, SWU, NWU, },
    { NED_, 2, SWU, NWU, },
    { SWM_, 4, NWD, NED, NWU, NEU, },
    { SMM_, 4, NWD, NED, NWU, NEU, },
    { SEM_, 2, NWD, NWU, },
    { MEM_, 4, SWD, NWD, SWU, NWU, },
    { NEM_, 4, SWD, NWD, SWU, NWU, },
    { SWU_, 4, NWD, NED, NWU, NEU, },
    { SMU_, 4, NWD, NED, NWU, NEU, },
    { SEU_, 2, NWD, NWU, },
    { MEU_, 4, SWD, NWD, SWU, NWU, },
    { NEU_, 4, SWD, NWD, SWU, NWU, },
  },
  { /* 6 SEU */ 
    { SWD_, 2, SEU, NEU, },
    { MWD_, 2, SEU, NEU, },
    { NWD_, 1, SEU, },
    { SMD_, 4, SWU, NWU, SEU, NEU, },
    { MMD_, 4, SWU, NWU, SEU, NEU, },
    { NMD_, 2, SWU, SEU, },
    { SED_, 4, SWU, NWU, SEU, NEU, },
    { MED_, 4, SWU, NWU, SEU, NEU, },
    { NED_, 2, SWU, SEU, },
    { SWM_, 4, SED, NED, SEU, NEU, },
    { MWM_, 4, SED, NED, SEU, NEU, },
    { NWM_, 2, SED, SEU, },
    { NMM_, 4, SWD, SED, SWU, SEU, },
    { NEM_, 4, SWD, SED, SWU, SEU, },
    { SWU_, 4, SED, NED, SEU, NEU, },
    { MWU_, 4, SED, NED, SEU, NEU, },
    { NWU_, 2, SED, SEU, },
    { NMU_, 4, SWD, SED, SWU, SEU, },
    { NEU_, 4, SWD, SED, SWU, SEU, },
  },
  { /* 7 NEU */ 
    { SWD_, 1, NEU, },
    { MWD_, 2, SEU, NEU, },
    { NWD_, 2, SEU, NEU, },
    { SMD_, 2, NWU, NEU, },
    { MMD_, 4, SWU, NWU, SEU, NEU, },
    { NMD_, 4, SWU, NWU, SEU, NEU, },
    { SED_, 2, NWU, NEU, },
    { MED_, 4, SWU, NWU, SEU, NEU, },
    { NED_, 4, SWU, NWU, SEU, NEU, },
    { SWM_, 2, NED, NEU, },
    { MWM_, 4, SED, NED, SEU, NEU, },
    { NWM_, 4, SED, NED, SEU, NEU, },
    { SMM_, 4, NWD, NED, NWU, NEU, },
    { SEM_, 4, NWD, NED, NWU, NEU, },
    { SWU_, 2, NED, NEU, },
    { MWU_, 4, SED, NED, SEU, NEU, },
    { NWU_, 4, SED, NED, SEU, NEU, },
    { SMU_, 4, NWD, NED, NWU, NEU, },
    { SEU_, 4, NWD, NED, NWU, NEU, },
  },
};


#endif

enum {STANDARD_THREAD=0 ,FARFIELD_THREAD=1, NEARFIELD_THREAD=2};


void* non_adaptive_fmm_ws2(GenericFmmThreadArg *arg)
{
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box, *box1, *box2;
    int level;
    int i, j;
    void (*GEN_M)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*EVAL_DIRECT)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }	
   
    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/
	/* Form multipole expansions at finest level */
	stat_start(FMMV, STAT_GEN_M);	
	if (FMMV->maxLevel>1) {
		for (box=FMMV->firstSourceBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextSourceBox) {
			GEN_M(FMMV, box);
		}
	}
	stat_stop(FMMV, STAT_GEN_M);	

	/* Form multipole expansions at coarser levels by merging */
	stat_start(FMMV, STAT_M2M);
        init_M2M(FMMV, -1);	
	for (level=FMMV->maxLevel-1; level>=2; level--) {
                init_M2M(FMMV, level);
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
			M2M(FMMV, box);
		}	
	}
        finish_M2M(FMMV);
	stat_stop(FMMV, STAT_M2M);	

	/*** Downward Pass ***/
	stat_start(FMMV, STAT_M2L);
        init_M2L(FMMV, -1);
	if (FMMV->reducedScheme) {	
		for (level=2; level<=FMMV->maxLevel; level++) {
                init_M2L(FMMV, level);
		/* Convert multipole to exponential expansions and shift exponential expansions */
			for (box=FMMV->firstSourceBoxOfLevel[level-2]; box!=0; box=box->nextSourceBox) {
				M2L_ws2_reduced(FMMV, box);
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) {
						for (j=0; j<FMM_CHILDS_PER_BOX; j++) {
							if (box->child[i]->child[j]) {
								FREE_M(FMMV, box->child[i]->child[j]->M);
							}
						}	
					}	
				}
			}	
		}
	}	
	else {
		for (level=2; level<=FMMV->maxLevel; level++) {
                init_M2L(FMMV, level);
		/* Convert multipole to exponential expansions and shift exponential expansions */
			for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
				M2L_ws2(FMMV, box);
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) FREE_M(FMMV, box->child[i]->M);
				}
			}	
		}	
	}
        finish_M2L(FMMV);
	stat_stop(FMMV, STAT_M2L);	

	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);
        init_L2L(FMMV, -1);
	for (level=2; level<=FMMV->maxLevel; level++) {
                init_L2L(FMMV, level-1);
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; box!=0; box=box->nextTargetBox) {
			L2L(FMMV, box);
			FREE_L(FMMV, box->L);
		}	
	}
        finish_L2L(FMMV);
	stat_stop(FMMV, STAT_L2L);	
	
	/*** Evaluation of Potentials ***/
	stat_start(FMMV, STAT_EVAL_L);	
	if (thread==STANDARD_THREAD) {
		if (FMMV->maxLevel>1) {
			for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
				/* Evaluate local expansions at finest level */
 				EVAL_L(FMMV, box);
				FREE_L(FMMV, box->L);
                	}			
		}
	} /* if (thread==STANDARD_THREAD) */
	#ifdef USE_PTHREADS
	else { /* if (thread==FARFIELD_THREAD) */
		if (FMMV->maxLevel>1) {
			for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
				/* Evaluate local expansions at finest level */
				pthread_mutex_lock(&(box->parent->mutex));
				pthread_mutex_lock(&(box->mutex));
 				EVAL_L(FMMV, box);
				pthread_mutex_unlock(&(box->mutex));
				pthread_mutex_unlock(&(box->parent->mutex));
				FREE_L(FMMV, box->L);
			}	
		}	
	} /* if (thread==FARFIELD_THREAD) */
	#endif   
	stat_stop(FMMV, STAT_EVAL_L);	
   } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */

   if (thread==STANDARD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel<=1) {	
		box=FMMV->firstTargetBoxOfLevel[0];
		EVAL_DIRECT(FMMV, box, box);
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			EVAL_DIRECT(FMMV, box, box);
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[theseParentNeighbors[box->whichChild][i]];
				EVAL_DIRECT(FMMV, box, box1);
			}
			for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) {
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						EVAL_DIRECT(FMMV, box, box2);
					}	
				}
			}
		}	
	}	
	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==STANDARD_THREAD) */

#ifdef USE_PTHREADS
   if (thread==NEARFIELD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel<=1) {	
		box=FMMV->firstTargetBoxOfLevel[0];
		EVAL_DIRECT(FMMV, box, box);
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			EVAL_DIRECT(FMMV, box, box);
			pthread_mutex_unlock(&(box->mutex));
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			if (FMMV->targets) { /* no lock for source boxes */
			    for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[theseParentNeighbors[box->whichChild][i]];
				if (box1) {
					EVAL_DIRECT(FMMV, box, box1);
				}
			    }
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) {
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						if (box2) {
							EVAL_DIRECT(FMMV, box, box2);
						}
					}	
				}
			    }	
			}
			else {	
			    for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[theseParentNeighbors[box->whichChild][i]];
				if (box1) {
					pthread_mutex_lock(&(box1->mutex));
					EVAL_DIRECT(FMMV, box, box1);
					pthread_mutex_unlock(&(box1->mutex));
				}
			    }
			    for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) {
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						if (box2) {
							pthread_mutex_lock(&(box2->mutex));
							EVAL_DIRECT(FMMV, box, box2);
							pthread_mutex_unlock(&(box2->mutex));
						}
					}	
				}
			    }	
			}
			pthread_mutex_unlock(&(box->mutex));
		}	
	}	
	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==NEARFIELD_THREAD) */
#endif	
   
   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
}


/* boundarysData is defined in generic_fmm.c */
extern int boundarysData[];

typedef struct {
	_FLOAT_ dx, dy;
	#if (FMM_DIM>=3)
	_FLOAT_ dz;
	#endif
} PeriodicShift;

/* pS is defined in generic_fmm.c */
extern PeriodicShift pS[]; 



void* non_adaptive_fmm_periodic_ws2(GenericFmmThreadArg *arg)
{
    FmmvHandle *FMMV = arg->fh;
    int thread = arg->thread;    
    Box *box, *box1, *box2;
    int level;
    int i, j, k, jj;
    void (*GEN_M)(FmmvHandle *FMMV, Box *box) = FMMV->gen_M;
    void (*EVAL_L)(FmmvHandle *FMMV, Box *box) = FMMV->eval_L;
    void (*EVAL_DIRECT)(FmmvHandle *FMMV, Box *target, Box *source) = FMMV->eval_direct;
    void (*EVAL_DIRECT_periodic)(FmmvHandle *FMMV, Box *target, Box *source, _FLOAT_ dx, _FLOAT_ dy
	#if (FMM_DIM>=3)
    	, _FLOAT_ dz
	#endif
	) = FMMV->eval_direct_periodic;

    switch(thread) {
    case (FARFIELD_THREAD):
	stat_start(FMMV, STAT_FARFIELD);	
	break;
    case (NEARFIELD_THREAD):
	stat_start(FMMV, STAT_NEARFIELD);	
	break;
    default:	
	break;
    }	
		    
    if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) {
	/*** Upward Pass ***/
	/* Form multipole expansions at finest level */
	stat_start(FMMV, STAT_GEN_M);	
	for (box=FMMV->firstSourceBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextSourceBox) {
		GEN_M(FMMV, box);
	}
	stat_stop(FMMV, STAT_GEN_M);	

	/* Form multipole expansions at coarser levels by merging */
	stat_start(FMMV, STAT_M2M);	
        init_M2M(FMMV, -1);
	for (level=FMMV->maxLevel-1; level>=0; level--) {/* note: now compute M up to level 0 */
		for (box=FMMV->firstSourceBoxOfLevel[level]; box!=0; box=box->nextSourceBox) {
                        init_M2M(FMMV, level);
			M2M(FMMV, box);
		}	
	}
        finish_M2M(FMMV);
	stat_stop(FMMV, STAT_M2M);	

	/*** Downward Pass ***/
	stat_start(FMMV, STAT_M2L);
        init_M2L(FMMV, -1);
	/******************************************************************/
	FMMV->firstSourceBoxOfLevel[0]->L = (_FLOAT_ *) FMMV_MALLOC(FMMV, FMM_SIZE_OF_L(FMMV->pL)*sizeof(_FLOAT_));

#ifdef USE_PTHREADS
	if (thread==FARFIELD_THREAD) {
		pthread_mutex_lock(&(FMMV->firstSourceBoxOfLevel[0]->mutex));
	}
#endif	
	
	periodic_lattice_M2L(FMMV, FMMV->firstSourceBoxOfLevel[0]->M, FMMV->firstSourceBoxOfLevel[0]->L);

#ifdef USE_PTHREADS
	if (thread==FARFIELD_THREAD) {
		pthread_mutex_unlock(&(FMMV->firstSourceBoxOfLevel[0]->mutex));
	}
#endif	
	FREE_M(FMMV, FMMV->firstSourceBoxOfLevel[0]->M);
	/******************************************************************/
	if (FMMV->reducedScheme) {
		/* we need an artificial parent for root */	
		Box parentOfRoot;
		box = FMMV->firstSourceBoxOfLevel[0];
		parentOfRoot.level = -1;
		box->whichChild=0;
		box->parent=&parentOfRoot;
		for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
			parentOfRoot.child[i] = box;
		}	
		for (i=0; i<26; i++) {
			parentOfRoot.neighbor[i] = &parentOfRoot;
		}
		for (i=0; i<6; i++) {
			parentOfRoot.X[i] = 0;
			parentOfRoot.X2[i] = 0;
		}
                init_M2L(FMMV, 1);
		M2L_ws2_reduced(FMMV, &parentOfRoot);
		box = FMMV->firstSourceBoxOfLevel[0];
		for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
			if (box->child[i]) {
				FREE_M(FMMV, box->child[i]->M);
			}	
		}
		
		for (level=2; level<=FMMV->maxLevel; level++) {
		/* Convert multipole to exponential expansions and shift exponential expansions */
                        init_M2L(FMMV, level);
			for (box=FMMV->firstSourceBoxOfLevel[level-2]; box!=0; box=box->nextSourceBox) {
				M2L_ws2_reduced(FMMV, box);
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) {
						for (j=0; j<FMM_CHILDS_PER_BOX; j++) {
							if (box->child[i]->child[j]) {
								FREE_M(FMMV, box->child[i]->child[j]->M);
							}	
					}	}
				}
			}	
		}
	}	
	else {
		for (level=1; level<=FMMV->maxLevel; level++) {
		/* Convert multipole to exponential expansions and shift exponential expansions */
                        init_M2L(FMMV, level);
			for (box=FMMV->firstSourceBoxOfLevel[level-1]; box!=0; box=box->nextSourceBox) {
				M2L_ws2(FMMV, box);
				for (i=0; i<FMM_CHILDS_PER_BOX; i++) {
					if (box->child[i]) FREE_M(FMMV, box->child[i]->M);
				}
			}	
		}	
	}
        finish_M2L(FMMV);
	stat_stop(FMMV, STAT_M2L);

	/* Shift local expansions from each parent to each of its children */
	stat_start(FMMV, STAT_L2L);	
        init_L2L(FMMV, -1);
	for (level=1; level<=FMMV->maxLevel; level++) {
                init_L2L(FMMV, level-1);
		for (box=FMMV->firstTargetBoxOfLevel[level-1]; box!=0; box=box->nextTargetBox) {
			L2L(FMMV, box);
			FREE_L(FMMV, box->L);
		}	
	}	
        finish_L2L(FMMV);	
	stat_stop(FMMV, STAT_L2L);	
	
	/*** Evaluation of Potentials ***/
	stat_start(FMMV, STAT_EVAL_L);	
	if (thread==STANDARD_THREAD) {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			/* Evaluate local expansions at finest level */
 			EVAL_L(FMMV, box);
			FREE_L(FMMV, box->L);
                }			
	} /* if (thread==STANDARD_THREAD) */
	#ifdef USE_PTHREADS
	else { /* if (thread==FARFIELD_THREAD) */
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			/* Evaluate local expansions at finest level */
			pthread_mutex_lock(&(box->mutex));
			pthread_mutex_lock(&(box->parent->mutex));
 			EVAL_L(FMMV, box);
			pthread_mutex_unlock(&(box->mutex));
			pthread_mutex_unlock(&(box->parent->mutex));
			FREE_L(FMMV, box->L);
		}	
	} /* if (thread==FARFIELD_THREAD) */
	#endif   
	stat_stop(FMMV, STAT_EVAL_L);	
   } /* if ((thread==STANDARD_THREAD)||(thread==FARFIELD_THREAD)) */

   if (thread==STANDARD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel==0) {	
		int dx, dy;
		#if (FMM_DIM>=3)
	        int dz;
		#endif
		box=FMMV->firstTargetBoxOfLevel[0];
		EVAL_DIRECT(FMMV, box, box);
		for (dx=-2; dx<=+2; dx++) {
		for (dy=-2; dy<=+2; dy++) {
		#if (FMM_DIM>=3)
		for (dz=-2; dz<=+2; dz++) {
		#endif
			   if (!((dx==0)&&(dy==0)
				#if (FMM_DIM>=3)
				&&(dz==0)
				#endif
				)) {
				EVAL_DIRECT_periodic(FMMV, box, box, dx, dy
					#if (FMM_DIM>=3)
					, dz
					#endif
					);
			   }	
		#if (FMM_DIM>=3)
		}
		#endif
		}}
	}	
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			EVAL_DIRECT(FMMV, box, box);
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[k=theseParentNeighbors[box->whichChild][i]];
				if (isSource(box1)) { /*&& (box1->firstParticle < box->firstParticle) */
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					EVAL_DIRECT_periodic(FMMV, box, box1, pS[jj].dx, pS[jj].dy
						#if (FMM_DIM>=3)
						, pS[jj].dz
						#endif
						);
				}	
			}
			for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[k=otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) {
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						EVAL_DIRECT_periodic(FMMV, box, box2, pS[jj].dx, pS[jj].dy
						#if (FMM_DIM>=3)
						, pS[jj].dz
						#endif
						);
					}	
				}
			}
		}	
	}	
	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==STANDARD_THREAD) */
   
#ifdef USE_PTHREADS
   if (thread==NEARFIELD_THREAD) {
	stat_start(FMMV, STAT_LIST1);	
	if (FMMV->maxLevel==0) {	
		int dx, dy;
		#if (FMM_DIM>=3)
		int dz;
		#endif
		box=FMMV->firstTargetBoxOfLevel[0];
		pthread_mutex_lock(&(box->mutex));
		EVAL_DIRECT(FMMV, box, box);
		for (dx=-2; dx<=+2; dx++) {
		for (dy=-2; dy<=+2; dy++) {
		#if (FMM_DIM>=3)
		for (dz=-2; dz<=+2; dz++) {
		#endif
			   if (!((dx==0)&&(dy==0)
				#if (FMM_DIM>=3)
				&&(dz==0)
				#endif
				)) {
				EVAL_DIRECT_periodic(FMMV, box, box, dx, dy
					#if (FMM_DIM>=3)
					, dz
					#endif
					);
			   }	
		#if (FMM_DIM>=3)
		}
		#endif
		}}    
		pthread_mutex_unlock(&(box->mutex));
	}
	else {
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel-1]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			EVAL_DIRECT(FMMV, box, box);
			pthread_mutex_unlock(&(box->mutex));
		}
		for (box=FMMV->firstTargetBoxOfLevel[FMMV->maxLevel]; box!=0; box=box->nextTargetBox) {
			pthread_mutex_lock(&(box->mutex));
			if (FMMV->targets) { /* no lock for source boxes */
			    for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[k=theseParentNeighbors[box->whichChild][i]];
				if (isSource(box1)) { /*&& (box1->firstParticle < box->firstParticle) */
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					EVAL_DIRECT_periodic(FMMV, box, box1, pS[jj].dx, pS[jj].dy
						#if (FMM_DIM>=3)
						, pS[jj].dz
						#endif
						);
				}
			     }
			     for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[k=otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) { /* && (box1->firstParticle < box->firstParticle)) { */
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						if(box2) {
							EVAL_DIRECT_periodic(FMMV, box, box2, pS[jj].dx, pS[jj].dy
								#if (FMM_DIM>=3)
								, pS[jj].dz
								#endif
								);
						}
					}	
				}
			    }
			}
			else {	
			    for (i=0; i<FMM_CHILDS_PER_BOX-1; i++) {
				box1 = box->parent->neighbor[k=theseParentNeighbors[box->whichChild][i]];
				if (isSource(box1)) { /*&& (box1->firstParticle < box->firstParticle) */
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					pthread_mutex_lock(&(box1->mutex));
					EVAL_DIRECT_periodic(FMMV, box, box1, pS[jj].dx, pS[jj].dy
						#if (FMM_DIM>=3)
						, pS[jj].dz
						#endif
						);
					pthread_mutex_unlock(&(box1->mutex));
				}
			     }
			     for (i=0; i<N_OTHER_NEIGHBORS; i++) {
				box1 = box->parent->neighbor[k=otherParentNeighborsChilds[box->whichChild][i][0]];
				if (isSource(box1)) { /* && (box1->firstParticle < box->firstParticle)) { */
					jj=((box->parent->atBoundary) & (boundarysData[k]));
					for (j=2; j<otherParentNeighborsChilds[box->whichChild][i][1]+2; j++) {
						box2 = box1->child[otherParentNeighborsChilds[box->whichChild][i][j]];
						if(box2) {
							pthread_mutex_lock(&(box2->mutex));
							EVAL_DIRECT_periodic(FMMV, box, box2, pS[jj].dx, pS[jj].dy
								#if (FMM_DIM>=3)
								, pS[jj].dz
								#endif
								);
							pthread_mutex_unlock(&(box2->mutex));
						}
					}	
				}
			    }
			}	
			pthread_mutex_unlock(&(box->mutex));
		}	
	}	
	stat_stop(FMMV, STAT_LIST1);	
   } /* if (thread==NEARFIELD_THREAD) */
#endif	

   
   switch(thread) {
   case (FARFIELD_THREAD):
	stat_stop(FMMV, STAT_FARFIELD);	
	break;
   case (NEARFIELD_THREAD):
	stat_stop(FMMV, STAT_NEARFIELD);	
	break;
   default:	
	break;
   }	
   return 0;
}	

